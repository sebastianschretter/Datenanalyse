import pandas as pd
import tkinter as tk
from tkinter import filedialog, ttk
from tkinter import messagebox
import re
from tkinter import filedialog

class App(tk.Tk):
    def __init__(self):
        super().__init__()
        self.sort_order = "asc"
        self.title("CSV Analyse Tool")
        self.df = None
        
        # Titel für das Programm
        self.program_title = tk.Label(self, text="PIMS-Auswertungstool", font=("Arial", 24))
        self.program_title.grid(row=0, column=0, columnspan=3, pady=(10, 30))

        # Frame für den oberen Bereich (Buttons und Labels)
        self.top_frame = tk.Frame(self)
        self.top_frame.grid(row=1, column=0, columnspan=3, pady=20, padx=10, sticky='ew') 
        self.top_frame.grid_columnconfigure(0, weight=1)
        self.top_frame.grid_columnconfigure(1, weight=1)
        self.top_frame.grid_columnconfigure(2, weight=1)

        # Hinweis-Text und Button zum Öffnen von CSV (Links)
        self.load_file_label = tk.Label(self.top_frame, text="Datei zur Auswertung laden:")
        self.load_file_label.grid(row=0, column=0, sticky='w', pady=(0,10))

        self.btn_open = tk.Button(self.top_frame, text="CSV öffnen", command=self.open_csv)
        self.btn_open.grid(row=1, column=0, sticky='w')

        self.file_entry = tk.Entry(self.top_frame, bd=1, relief="solid", state='readonly') 
        self.file_entry.grid(row=2, column=0, padx=(0,10), sticky='ew')

        self.btn_reset = tk.Button(self.top_frame, text="Reset", command=self.reset_program)
        self.btn_reset.grid(row=3, column=0, sticky='w')

        # Exportieren Button (Mitte)
        # Hinweis-Text 
        self.load_file_label = tk.Label(self.top_frame, text="Datei exportieren:")
        self.load_file_label.grid(row=0, column=1, sticky='ew', pady=(0,10))
        
        self.btn_export = tk.Button(self.top_frame, text="Exportieren", command=self.export_to_excel)
        self.btn_export.grid(row=1, column=1)

        # Zukünftiger Gesamtauswertung Button (Rechts)
        # Hinweis-Text
        self.load_file_label = tk.Label(self.top_frame, text="Gesamtauswertung starten:")
        self.load_file_label.grid(row=0, column=2, sticky='e', pady=(0,10))
        
        self.btn_total_evaluation = tk.Button(self.top_frame, text="Gesamtauswertung", command=self.gesamtauswertung)
        self.btn_total_evaluation.grid(row=1, column=2, sticky='e')

        # Treeview für die Tabelle
        self.tree = ttk.Treeview(self, columns=('Halle', 'Anlage', 'Anzahl', 'Störungskürzel'), show='headings')
        self.tree.heading('Halle', text='Halle')
        self.tree.heading('Anlage', text='Anlage')
        self.tree.heading('Anzahl', text='Anzahl', command=lambda: self.sort_by_anzahl())
        self.tree.heading('Störungskürzel', text='Störungskürzel')
        self.tree.grid(row=2, column=0, padx=10, sticky='nsew')

        # Scrollbar für die Tabelle 
        self.scrollbar = ttk.Scrollbar(self, orient='vertical', command=self.tree.yview)
        self.tree.configure(yscrollcommand=self.scrollbar.set)
        self.scrollbar.grid(row=2, column=1, sticky='ns')

        # Textfeld rechts von der Tabelle
        self.text_entry = tk.Text(self, width=30)
        self.text_entry.grid(row=2, column=2, padx=10, pady=10, sticky='nsew')

        # Wörterbuch zum Speichern von Kommentaren
        self.comments = {}
        
        # Frame für die Kommentar-Buttons
        comment_buttons_frame = tk.Frame(self)
        comment_buttons_frame.grid(row=3, column=2, sticky='ew')

        # Buttons für Kommentar-Funktionen
        # Speichern-Button
        self.btn_save_comment = tk.Button(comment_buttons_frame, text="Speichern", command=self.save_comment)
        self.btn_save_comment.grid(row=1, column=0, sticky='ew', padx=(10,5), pady=(5,5))

        # Löschen-Button
        self.btn_delete_comment = tk.Button(comment_buttons_frame, text="Löschen", command=self.delete_comment)
        self.btn_delete_comment.grid(row=1, column=1, sticky='ew', padx=(5,10), pady=(5,5))
        
        # Einstellen, dass Buttons mit Spalte wachsen
        # Dies stellt sicher, dass die Spalten im comment_buttons_frame mitwachsen
        comment_buttons_frame.grid_columnconfigure(0, weight=1)
        comment_buttons_frame.grid_columnconfigure(1, weight=1)

        # Klick-Event für die Treeview
        self.tree.bind('<ButtonRelease-1>', self.on_tree_select)

        # Einstellen, dass die Spalten und Zeilen mit der Fenstergröße wachsen
        self.grid_rowconfigure(1, weight=1)
        self.grid_columnconfigure(0, weight=1)
        self.grid_columnconfigure(2, weight=1)

        # Filter-Komboboxen und Label erstellen
        self.filter_label_halle = tk.Label(self, text="Halle filtern:")
        self.filter_label_halle.grid(row=3, column=0, padx=10, sticky='w')

        self.combo_halle = ttk.Combobox(self, values=[], state="readonly")
        self.combo_halle.grid(row=4, column=0, padx=10, sticky='ew')

        self.filter_label_sk = tk.Label(self, text="Störungskürzel filtern:")
        self.filter_label_sk.grid(row=5, column=0, padx=10, sticky='w')

        self.combo_sk = ttk.Combobox(self, values=[], state="readonly")
        self.combo_sk.grid(row=6, column=0, padx=10, sticky='ew')

        # Filter-Schaltfläche
        self.btn_filter = tk.Button(self, text="Filtern", command=self.apply_filters)
        self.btn_filter.grid(row=7, column=0, padx=10, pady=10, sticky='e')

    # Tagesauswertung
    def analyse_meldungsname(self, csv_path):
        
        def get_störungskürzel(priority):
            if priority in ["14", "15", "16"]:
                return "ST"
            elif priority in ["11", "13"]:
                return "WN"
            elif priority in ["9", "10"]:
                return "LTST"
            elif priority in ["3", "6"]:
                return "LOG"
            else:
                return "SO"

        def extract_anlage_name_from_pcs7(name):
            # Extrahiere Priorität
            prioritaet_match = re.search(r'\.(\d{1,2})\.', name)
            prioritaet = int(prioritaet_match.group(1)) if prioritaet_match else None

            # Extrahiere Halle
            halle_match = re.search(r'VIH\+([^\.]+)', name)
            halle = halle_match.group(1) if halle_match else None

            # Anlage Extrahieren
            anlage_match = re.search(r'_._[A-Z0-9]{4}_([A-Za-z0-9_]+_[A-Za-z0-9_]+?)(?:_\d|_)', name)
            if anlage_match:
                anlage_raw = anlage_match.group(1).replace('_', ' ')
                anlage_parts = anlage_raw.split(' ')
                if len(anlage_parts) > 2:
                    anlage = ' '.join(anlage_parts[:2])
                else:
                    anlage = anlage_raw
            else:
                anlage = None

            return prioritaet, halle, anlage

        df = pd.read_csv(csv_path, delimiter=';')
        meldungsname = df["Meldungsname"]

        analysis_result = []

        for name in meldungsname:
            # Verarbeitung der SiclilmatX - Meldungen
            if name.startswith("H") and name[1:3].isdigit():
                try:
                    parts = name.split('.')
                    halle = parts[0]
                    anlage = parts[4].replace('_', '').strip()
                    störungskürzel = parts[-1]
                    analysis_result.append([halle, anlage, 1, störungskürzel])
                except IndexError:
                    continue
            
            # Verarbeitung der PCS7 - Meldungen
            else:
                try:
                    parts = name.split('.')
                    standort = parts[4].split('+')[1].split('.')[0]
                    
                    # Wenn der Standort "B13a" ist, wird er in "H13a" geändert
                    if standort == "B13a":
                        standort = "H13a"
                    
                    prioritaet, halle, anlage = extract_anlage_name_from_pcs7(name)
                    störungkürzel = get_störungskürzel(str(prioritaet))

                    analysis_result.append([standort, anlage, 1, störungkürzel])
                except IndexError:
                    continue

        result_df = pd.DataFrame(analysis_result, columns=['Halle', 'Anlage', 'Anzahl', 'Störungskürzel'])
        return result_df.groupby(['Halle', 'Anlage', 'Störungskürzel']).size().reset_index(name='Anzahl')

    # Gesamtauswertung
    def gesamtauswertung(self):
        # Überprüfen Sie, ob bereits Daten geladen sind
        if self.df is not None and not self.df.empty:
            response = messagebox.askyesnocancel("Warnung", "Es gibt bereits geladene Daten. Wenn Sie fortfahren, werden diese Daten überschrieben. Möchten Sie die aktuellen Daten exportieren?")
            if response == True:
                # Daten exportieren
                self.export_to_excel()
                
                # Liste leeren
                self.df = pd.DataFrame()
                
                # Hier können Sie auch Ihre GUI-Tabelle aktualisieren, falls erforderlich
                
                return  # Verlassen Sie die Funktion, nachdem die Daten exportiert wurden
            elif response == False:
                return  # Verlassen Sie die Funktion, wenn der Benutzer "Nein" wählt
            else:
                return  # Verlassen Sie die Funktion, wenn der Benutzer das Fenster schließt oder "Abbrechen" wählt
            
        # Mehrere Dateien auswählen
        file_paths = filedialog.askopenfilenames(title="Mehrere Exportdateien auswählen",
                                                filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")])
        if not file_paths:
            return

        # Alle Datenframes in einer Liste sammeln
        dfs = []
        for path in file_paths:
            df = pd.read_excel(path)
            dfs.append(df)

        # Datenframes zusammenführen
        combined_df = pd.concat(dfs, ignore_index=True)

        # Einträge gruppieren und Anzahl summiert
        grouped_df = combined_df.groupby(['Halle', 'Anlage', 'Störungskürzel']).agg({
            'Anzahl': 'sum'
        }).reset_index()
        

        # Den gruppierten Datenframe speichern
        self.df = grouped_df
        
        # Comboboxen aktualisieren
        self.update_comboboxes()

        # Nun können Sie die Daten in Ihrer GUI-Tabelle anzeigen.
        self.populate_table()

    # Zusätzliche Methode, um die Tabelle mit Daten zu füllen
    def populate_table(self):
        # Die Tabelle leeren
        for i in self.tree.get_children():
            self.tree.delete(i)

        # Daten in die Tabelle einfügen
        for index, row in self.df.iterrows():
            self.tree.insert("", tk.END, values=(row['Halle'], row['Anlage'], row['Anzahl'], row['Störungskürzel'], row.get('Kommentar', '')))

    def open_csv(self):
        file_path = filedialog.askopenfilename()
        if file_path:
            # Zeige den Dateinamen im Textfeld an
            filename = file_path.split("/")[-1]
            self.file_entry.config(state='normal') 
            self.file_entry.delete(0, tk.END)      
            self.file_entry.insert(0, filename)     
            self.file_entry.config(state='readonly')


            # Treeview leeren
            for i in self.tree.get_children():
                self.tree.delete(i)
            
            self.df = self.analyse_meldungsname(file_path)
            for index, row in self.df.iterrows():
                self.tree.insert("", tk.END, values=(row['Halle'], row['Anlage'], row['Anzahl'], row['Störungskürzel']))
            self.update_comboboxes()

    def update_comboboxes(self):
        if self.df is not None:
            hallen = ["Alles"] + sorted(self.df['Halle'].unique())
            sks = ["Alles"] + sorted(self.df['Störungskürzel'].unique())
            self.combo_halle['values'] = hallen
            self.combo_sk['values'] = sks

    def filter_df(self):
        halle_filter = self.combo_halle.get()
        sk_filter = self.combo_sk.get()

        filtered_df = self.df

        if halle_filter != "Alles":
            filtered_df = filtered_df[filtered_df['Halle'].isin([halle_filter])]
        if sk_filter != "Alles":
            filtered_df = filtered_df[filtered_df['Störungskürzel'].isin([sk_filter])]

        return filtered_df      

    def apply_filters(self):
        # Überprüfung, ob eine Datei geladen wurde
        if self.df is None:
            messagebox.showwarning("Fehler", "Bitte laden Sie zuerst eine Datei, bevor Sie filtern!")
            return

        filtered_df = self.filter_df()

        # Die Tabelle leeren
        for i in self.tree.get_children():
            self.tree.delete(i)

        # Die gefilterten Daten anzeigen
        for index, row in filtered_df.iterrows():
            self.tree.insert("", tk.END, values=(row['Halle'], row['Anlage'], row['Anzahl'], row['Störungskürzel']))

    # Funktion, die aufgerufen wird, wenn ein Eintrag in der Treeview ausgewählt wird
    def on_tree_select(self, event):
        self.text_entry.delete(1.0, tk.END)  # Leeren des Textfelds
        selected = self.tree.focus()
        values = self.tree.item(selected, 'values')
        if len(values) < 4:
            return
        halle, anlage, anzahl, sk = values
        key = (halle, anlage, sk)
        if key in self.comments:
            self.text_entry.insert(tk.END, self.comments[key])

    # Funktion zum Speichern des Kommentars
    def save_comment(self):
        selected = self.tree.focus()
        if not selected:  # Überprüfen, ob ein Eintrag ausgewählt ist
            messagebox.showwarning("Kein Eintrag ausgewählt", "Bitte wählen Sie eine Anlage aus, bevor Sie einen Kommentar speichern.")
            self.text_entry.delete(1.0, tk.END)  # Löscht den Inhalt des Textfeldes
            return

        values = self.tree.item(selected, 'values')
        halle, anlage, anzahl, sk = values
        key = (halle, anlage, sk)
        comment = self.text_entry.get(1.0, tk.END).strip()
        self.comments[key] = comment

    # Funktion zum Löschen des Kommentars
    def delete_comment(self):
        selected = self.tree.focus()
        if not selected:  # Überprüfen, ob ein Eintrag ausgewählt ist
            messagebox.showwarning("Kein Eintrag ausgewählt", "Bitte wählen Sie eine Anlage aus, bevor Sie einen Kommentar löschen.")
            self.text_entry.delete(1.0, tk.END)  # Löscht den Inhalt des Textfeldes
            return

        values = self.tree.item(selected, 'values')
        halle, anlage, anzahl, sk = values
        key = (halle, anlage, sk)
        if key in self.comments:
            del self.comments[key]
        self.text_entry.delete(1.0, tk.END)

    # Reset Funktion
    def reset_program(self):
        # Treeview leeren
        for i in self.tree.get_children():
            self.tree.delete(i)
        
        # Setzen Sie alle Eingabefelder, Filter und ComboBoxen zurück
        self.text_entry.delete(1.0, tk.END)
        self.combo_halle.set('')
        self.combo_sk.set('')

        # Löschen Sie alle Daten im Hintergrund, die in der Anwendung verwendet werden
        self.df = None
        self.comments = {}

        # Aktualisieren der Comboboxen
        self.combo_halle['values'] = []
        self.combo_sk['values'] = []

        # Dateinamen zurücksetzen
        self.file_entry.config(state=tk.NORMAL)
        self.file_entry.delete(0, tk.END)
        self.file_entry.config(state='readonly')

    # Funktion zum Sortieren der Anzahl
    def sort_by_anzahl(self):
        if self.sort_order == "asc":
            self.df = self.df.sort_values(by="Anzahl", ascending=False)
            self.sort_order = "desc"
        else:
            self.df = self.df.sort_values(by="Anzahl", ascending=True)
            self.sort_order = "asc"

        # Filtermethode aufrufen, um die gefilterte DataFrame zu erhalten
        filtered_df = self.filter_df()

        # Treeview leeren
        for i in self.tree.get_children():
            self.tree.delete(i)

        # Aktualisierte Daten anzeigen
        for index, row in filtered_df.iterrows():
            self.tree.insert("", tk.END, values=(row['Halle'], row['Anlage'], row['Anzahl'], row['Störungskürzel']))

    # Funktion zum Export der Daten
    def export_to_excel(self):
        # Überprüfung, ob eine Datei geladen wurde
        if self.df is None:
            messagebox.showwarning("Fehler", "Bitte laden Sie zuerst eine Datei, bevor Sie exportieren!")
            return

        # Erstellen Sie eine Kopie der DataFrame, damit die Originaldaten nicht geändert werden
        export_df = self.df.copy()

        # Eine leere "Kommentar" Spalte zur DataFrame hinzufügen
        export_df['Kommentar'] = ""

        # Füllen Sie die 'Kommentar'-Spalte mit den gespeicherten Kommentaren
        for index, row in export_df.iterrows():
            key = (row['Halle'], row['Anlage'], row['Störungskürzel'])
            if key in self.comments:
                export_df.at[index, 'Kommentar'] = self.comments[key]

        # Exportieren Sie die DataFrame in eine Excel-Datei
        file_path = filedialog.asksaveasfilename(defaultextension=".xlsx", filetypes=[("Excel files", "*.xlsx"), ("All files", "*.*")])
        if file_path:
            with pd.ExcelWriter(file_path, engine='openpyxl') as writer:
                export_df.to_excel(writer, index=False)
                
            messagebox.showinfo("Erfolgreicher Export", f"Die Daten wurden erfolgreich nach {file_path} exportiert!")

if __name__ == "__main__":
    app = App()
    app.mainloop()
